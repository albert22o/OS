### Добавь подробные комментарии к коду и установи родственные связи между процессами.

Создание приложения для запуска нескольких программ и управления процессами в Linux можно реализовать с помощью системных вызовов fork(), exec() и waitpid(). Давайте рассмотрим пример кода, который запускает несколько программ, устанавливает родственные связи и выводит дерево процессов с понятным для пользователя выводом.

Пример кода на C:
C
Скопировать
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

#define MAX_PROCESSES 5

// Функция для вывода дерева процессов
void print_process_tree(int level, pid_t pid, const char *name) {
    for (int i = 0; i < level; i++) {
        printf("  "); // Отступ для визуализации уровня
    }
    printf("Process ID: %d, Name: %s\n", pid, name);
}

// Главная функция
int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Использование: %s <путь к программе1> <путь к программе2> ...\n", argv[0]);
        return EXIT_FAILURE;
    }

    pid_t pids[MAX_PROCESSES];

    // Запуск процессов
    for (int i = 1; i < argc && i <= MAX_PROCESSES; i++) {
        pid_t pid = fork(); // Создаем новый процесс

        if (pid < 0) {
            perror("Ошибка fork");
            exit(EXIT_FAILURE);
        } else if (pid == 0) { // Дочерний процесс
            // Запускаем программу
            execvp(argv[i], &argv[i]); // execvp хэндлит аргументы
            perror("Ошибка execvp"); // Если execvp не удается
            exit(EXIT_FAILURE);
        } else { // Родительский процесс
            pids[i - 1] = pid; // Сохраняем идентификатор нового процесса
        }
    }

    // Ждем завершения процессов и выводим дерево процессов
    printf("Дерево процессов:\n");
    for (int i = 0; i < MAX_PROCESSES && pids[i] > 0; i++) {
        int status;
        waitpid(pids[i], &status, 0); // Ждем завершения дочернего процесса
        print_process_tree(1, pids[i], argv[i + 1]); // Печатаем дерево    
    }

    return EXIT_SUCCESS;
}

Объяснение кода:

Заголовочные файлы:

stdio.h: Для функций ввода/вывода.
stdlib.h: Для стандартных функций, например, exit().
unistd.h: Для системных вызовов, таких как fork() и execvp().
sys/types.h, sys/wait.h: Для работы с идентификаторами процессов и функциями ожидания.

MAX_PROCESSES:

Константа, определяющая максимальное количество процессов, которое мы можем запустить.

Функция print_process_tree(int level, pid_t pid, const char *name):

Рекурсивная функция, которая выводит идентификаторы процессов и их названия с отступами, которые визуализируют родственные связи.

main(int argc, char *argv[]):

Проверяет количество аргументов. Если не передано хотя бы одно название программы, выводится сообщение об ошибке.
В цикле создаются дочерние процессы для каждой программы, используя fork(). В дочернем процессе вызывается execvp(), чтобы запустить указанную программу.
В родительском процессе идентификаторы дочерних процессов сохраняются в массиве pids.

Ожидание процессов:

С помощью waitpid() родитель ждет завершения каждого дочернего процесса и вызывает функцию для вывода дерева процессов.
Запуск программы:
Скомпилировать: gcc -o process_manager process_manager.c
Запустить и передать названия программ: ./process_manager /path/to/program1 /path/to/program2

Этот код производит визуализацию процессов и устанавливает родственные связи между ними, а также выводит понятные сообщения для пользователя. Обратите внимание, что для корректной работы программы необходимо, чтобы переданные программы были доступны в указанном пути.