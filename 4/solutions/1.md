### Задание: разработать приложение, запускающее несколько программ. Определите идентификаторы соответствующих процессов. Установите родственные связи. Цель: получение навыков использования функций API создания процессов на платформе Linux.

Чтобы разработать приложение, которое запускает несколько программ и управляет процессами в Linux, мы можем использовать системные вызовы, такие как fork() и exec(). Эти функции позволяют создавать новые процессы и заменять их выполнение.

Основные концепции:
fork() — создаёт новый процесс (дочерний), который является копией родительского.
exec() — заменяет текущий процесс (родительский или дочерний) другим.
wait() — позволяет родительскому процессу ждать завершения дочернего.
Пример кода

Ниже представлен простейший пример программы на C, которая создаёт два дочерних процесса, каждый из которых запускает свою собственную программу (например, ls и date):

C
Скопировать
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid1, pid2;

    // Создание первого дочернего процесса
    pid1 = fork();
    if (pid1 < 0) {
        perror("Ошибка при fork()");
        exit(EXIT_FAILURE);
    }
    
    if (pid1 == 0) { // Дочерний процесс 1
        execlp("ls", "ls", NULL);
        perror("Ошибка при exec()");
        exit(EXIT_FAILURE);
    }

    // Создание второго дочернего процесса
    pid2 = fork();
    if (pid2 < 0) {
        perror("Ошибка при fork()");
        exit(EXIT_FAILURE);
    }

    if (pid2 == 0) { // Дочерний процесс 2
        execlp("date", "date", NULL);
        perror("Ошибка при exec()");
        exit(EXIT_FAILURE);
    }

    // Ожидание завершения дочерних процессов
    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);

    printf("Оба дочерних процесса завершены.\n");

    return 0;
}

Описание программы:

Создание процессов: Используем fork() для создания двух дочерних процессов.

Если fork() возвращает 0, мы находимся в дочернем процессе.
Если возвращает значение больше 0, это идентификатор (PID) дочернего процесса.

Запуск программ: В дочерних процессах используем execlp(), чтобы выполнить команды ls и date. Эта функция заменяет текущий контекст процесса новым исполняемым файлом.

Ожидание завершения: В родительском процессе используем waitpid() для ожидания завершения каждого дочернего процесса, обеспечивая таким образом правильные родственные связи.

Компиляция и запуск

Скомпилируйте код командой:

Bash
Копировать
gcc -o process_manager process_manager.c


Запустите приложение:

Bash
Копировать
./process_manager

Заключение

Эта программа демонстрирует основные принципы работы с процессами в Linux. Убедитесь, что Ваш код правильно обрабатывает ошибки и учитывает различные сценарии, такие как создание дополнительного количества процессов или динамическое назначение выполнений. Если у тебя есть другие вопросы или нужно углубиться в определённые аспекты работы с процессами, дай знать!