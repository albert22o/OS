#### Запуск
Компилируем программу
```
gcc -o task_manager task_manager.c
```
В терминале запуститься процесс. Открываем новый терминал и в нем подключаемся к серверу по telnet.
```
telnet 127.0.0.1 8080
```

#### Список операций:
1. list — показать список задач.
2. kill <PID> — завершить задачу с указанным PID.
3. priority <PID> <PRIORITY> — изменить приоритет задачи с указанным PID.
4. elf <FILE_PATH> — показать основную информацию об ELF-файле.
5. exit — завершить соединение.

#### Тест
Открываем третий терминал и запускаем в нем тестовую программу.
```
gcc -o test test.c
./test
```
Возвращаемся во второй терминал с открытым telnet и вызываем команду `list`. Там находим PID нашей тестовой программы и вырубаем ее через комманду `kill <PID>`.
Также можно просмотреть ELF файл тестовой программы, для этого пишем `elf ./test`, в терминале выдасться основная информация о файлу `test`. После чего можно выйти из программы, используя `exit`.

Чтобы вырубить сетевую службу, возвращаемся в первый терминал и ищем процессы, использующие порт 8080.
```
lsof -i :8080
```
Принудительно убиваем все процессы task_manager.
```
kill -9 <PID>
```

#### Заметки по ELF заголовкам
1. e_type
Указывает тип ELF-файла:
- 0 (ET_NONE) — неопределённый тип.
- 1 (ET_REL) — объектный файл, используемый на этапе компиляции (relocatable file).
- 2 (ET_EXEC) — исполняемый файл (executable file).
- 3 (ET_DYN) — позиционно-независимый файл (динамическая библиотека).
- 4 (ET_CORE) — дамп памяти (core dump).

2. e_machine
Архитектура процессора, для которой предназначен файл:
- 3 (EM_386) — 32-битный x86.
- 62 (EM_X86_64) — 64-битный x86 (x86-64).
- 40 (EM_ARM) — ARM.
- 243 (EM_RISCV) — RISC-V.

3. e_version
Версия ELF-файла. Обычно 1 (EV_CURRENT).

4. e_entry
Указывает виртуальный адрес точки входа в программу. Это место, где начинается выполнение кода, если файл является исполняемым.